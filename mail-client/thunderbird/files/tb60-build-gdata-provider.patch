
# HG changeset patch
# User Geoff Lankow <geoff@darktrojan.net>
# Date 1533166138 -43200
# Node ID b3975c8d27c10bfad83b9af956fea2bb43045b1a
# Parent  00325311f1a5d6e8d27a4364c1792232f52995bf
Bug 1471326 - Build GData Provider with Thunderbird and re-enable its test test_gdata_provider.js. r=philipp

diff --git a/calendar/lightning/versions.mk b/calendar/lightning/versions.mk
--- a/calendar/lightning/versions.mk
+++ b/calendar/lightning/versions.mk
@@ -7,18 +7,16 @@ THUNDERBIRD_VERSION := $(shell cat $(com
 SEAMONKEY_VERSION := $(shell cat $(commtopsrcdir)/suite/config/version.txt)
 
 ifdef MOZ_SUITE
 LIGHTNING_VERSION := $(shell $(PYTHON) $(commtopsrcdir)/calendar/lightning/build/makeversion.py $(THUNDERBIRD_VERSION))
 else
 LIGHTNING_VERSION := $(shell $(PYTHON) $(commtopsrcdir)/calendar/lightning/build/makeversion.py $(word 1,$(MOZ_PKG_VERSION) $(THUNDERBIRD_VERSION)))
 endif
 
-#GDATA_VERSION := $(shell $(PYTHON) $(commtopsrcdir)/calendar/providers/gdata/makeversion.py $(LIGHTNING_VERSION))
-
 # For extensions we require a max version that is compatible across security releases.
 # THUNDERBIRD_MAXVERSION and SEAMONKEY_MAXVERSION is our method for doing that.
 # Alpha versions 10.0a1 and 10.0a2 aren't affected
 # For Seamonkey, 2.17 becomes 2.17.*, 2.17.1 becomes 2.17.*
 # For Thunderbird, 10.0 becomes 10.*, 10.0.1 becomes 10.*
 THUNDERBIRD_MAXVERSION := $(THUNDERBIRD_VERSION)
 ifneq (a,$(findstring a,$(THUNDERBIRD_VERSION)))
 THUNDERBIRD_MAXVERSION := $(shell echo $(THUNDERBIRD_VERSION) | sed 's|\(^[0-9]*\)\.\([0-9]*\).*|\1|' ).*
diff --git a/calendar/providers/gdata/Makefile.in b/calendar/providers/gdata/Makefile.in
--- a/calendar/providers/gdata/Makefile.in
+++ b/calendar/providers/gdata/Makefile.in
@@ -1,33 +1,28 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-XPI_PKGNAME = gdata-provider-$(GDATA_VERSION).$(AB_CD).$(MOZ_PKG_PLATFORM)
-XPI_VERSION = $(GDATA_VERSION)
+XPI_NAME = gdata-provider
+XPI_PKGNAME = gdata-provider.$(AB_CD)
 XPI_EM_ID = {a62ef8ec-5fdc-40c2-873c-223b8a6925cc}
 XPI_INSTALL_EXTENSION = $(XPI_EM_ID)
 
-DEFINES += -DLIGHTNING_VERSION=$(LIGHTNING_VERSION) \
-           -DSEAMONKEY_VERSION=$(SEAMONKEY_VERSION) \
+ifdef MOZ_SUITE
+LIGHTNING_VERSION := $(shell $(PYTHON) $(commtopsrcdir)/calendar/lightning/build/makeversion.py $(THUNDERBIRD_VERSION))
+else
+LIGHTNING_VERSION := $(shell $(PYTHON) $(commtopsrcdir)/calendar/lightning/build/makeversion.py $(word 1,$(MOZ_PKG_VERSION) $(THUNDERBIRD_VERSION)))
+endif
+
+GDATA_VERSION := $(shell $(PYTHON) $(commtopsrcdir)/calendar/providers/gdata/makeversion.py $(LIGHTNING_VERSION))
+THUNDERBIRD_VERSION := $(shell cat $(commtopsrcdir)/mail/config/version.txt)
+SEAMONKEY_VERSION := $(shell cat $(commtopsrcdir)/suite/config/version.txt)
+
+DEFINES += -DSEAMONKEY_VERSION=$(SEAMONKEY_VERSION) \
            -DTHUNDERBIRD_VERSION=$(THUNDERBIRD_VERSION) \
-           -DCOMM_BUILD=$(COMM_BUILD) \
            -DGDATA_VERSION=$(GDATA_VERSION) \
            $(NULL)
 
-ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
-# If the macbundle dist dir was already created, sync the gdata provider here to avoid
-# the need to make -C objdir/mail/app each time
-tools repackage::
-	[ -d $(DIST)/$(MOZ_MACBUNDLE_NAME) ] && rsync -a $(FINAL_TARGET)/ $(DIST)/$(MOZ_MACBUNDLE_NAME)/Contents/Resources/extensions/$(XPI_EM_ID) || true
-endif
-
-# stage the extension for use in packaged tests
-PKG_STAGE = $(DIST)/test-stage
+include $(commtopsrcdir)/calendar/lightning/lightning-packager.mk
 
 stage-package:
-	$(NSINSTALL) -D $(PKG_STAGE)/extensions/$(XPI_EM_ID)
-	(cd $(FINAL_TARGET) && tar $(TAR_CREATE_FLAGS) - *) | (cd $(PKG_STAGE)/extensions/$(XPI_EM_ID) && tar -xf -)
-
-include $(moztopsrcdir)/config/rules.mk
-include $(commtopsrcdir)/calendar/lightning/versions.mk
-include $(commtopsrcdir)/calendar/lightning/lightning-packager.mk
+	$(PYTHON) -u $(MOZILLA_DIR)/build/upload.py $(DIST)/xpi-stage/$(XPI_PKGNAME).xpi
diff --git a/calendar/providers/gdata/install.rdf b/calendar/providers/gdata/manifest.json
rename from calendar/providers/gdata/install.rdf
rename to calendar/providers/gdata/manifest.json
--- a/calendar/providers/gdata/install.rdf
+++ b/calendar/providers/gdata/manifest.json
@@ -1,41 +1,23 @@
-<?xml version="1.0" encoding="UTF-8"?>
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
 #filter substitution
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-<RDF xmlns="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-     xmlns:em="http://www.mozilla.org/2004/em-rdf#">
-
-  <Description about="urn:mozilla:install-manifest">
-    <em:id>{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}</em:id>
-    <em:version>@GDATA_VERSION@</em:version>
-    <em:type>2</em:type>
-
-    <!-- Target Application this extension can install into,
-         with minimum and maximum supported versions. -->
-    <em:targetApplication>
-      <Description>
-        <!-- Thunderbird -->
-        <em:id>{3550f703-e582-4d05-9a08-453d09bdfdc6}</em:id>
-        <em:minVersion>52.0</em:minVersion>
-        <em:maxVersion>@THUNDERBIRD_VERSION@</em:maxVersion>
-      </Description>
-    </em:targetApplication>
-    <em:targetApplication>
-      <Description>
-        <!-- SeaMonkey -->
-        <em:id>{92650c4d-4b8e-4d2a-b7eb-24ecf4f6b63a}</em:id>
-        <em:minVersion>2.49</em:minVersion>
-        <em:maxVersion>@SEAMONKEY_VERSION@</em:maxVersion>
-      </Description>
-    </em:targetApplication>
-
-    <em:name>Provider for Google Calendar</em:name>
-    <em:description>Allows bidirectional access to Google Calendar</em:description>
-    <em:creator>Philipp Kewisch</em:creator>
-    <em:contributor>Mark James (http://www.famfamfam.com/lab/icons/silk/)</em:contributor>
-    <em:homepageURL>https://addons.mozilla.org/thunderbird/addon/4631</em:homepageURL>
-    <em:iconURL>chrome://gdata-provider/content/gcal.png</em:iconURL>
-  </Description>
-</RDF>
+{
+  "manifest_version": 2,
+  "name": "Provider for Google Calendar",
+  "description": "Allows bidirectional access to Google Calendar",
+  "version": "@GDATA_VERSION@",
+  "author": "Philipp Kewisch",
+  "homepage_url": "https://addons.mozilla.org/thunderbird/addon/4631",
+  "legacy": true,
+  "applications": {
+    "gecko": {
+      "id": "{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}",
+      "strict_min_version": "@THUNDERBIRD_VERSION@"
+    }
+  },
+  "icons": {
+    "32": "chrome://gdata-provider/content/gcal.png"
+  }
+}
diff --git a/calendar/providers/gdata/moz.build b/calendar/providers/gdata/moz.build
--- a/calendar/providers/gdata/moz.build
+++ b/calendar/providers/gdata/moz.build
@@ -1,16 +1,17 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 XPI_NAME = 'gdata-provider'
+export('XPI_NAME')
 
-FINAL_TARGET_PP_FILES += ['install.rdf']
+FINAL_TARGET_PP_FILES += ['manifest.json']
 
 DIRS += [
     'locales',
 ]
 
 EXTRA_JS_MODULES += [
     'modules/calUtilsShim.jsm',
     'modules/gdataLogging.jsm',
@@ -23,14 +24,17 @@ EXTRA_JS_MODULES += [
 
 EXTRA_COMPONENTS += [
     'components/calGoogleCalendar.js',
     'components/calGoogleCalendar.manifest',
 ]
 
 JAR_MANIFESTS += ['jar.mn']
 
+USE_EXTENSION_MANIFEST = True
+export('USE_EXTENSION_MANIFEST')
+
 JS_PREFERENCE_FILES += [
     'defaults/preferences.js',
 ]
 
 with Files('**'):
     BUG_COMPONENT = ('Calendar', 'Provider: GData')
diff --git a/calendar/test/unit/test_gdata_provider.js b/calendar/test/unit/test_gdata_provider.js
--- a/calendar/test/unit/test_gdata_provider.js
+++ b/calendar/test/unit/test_gdata_provider.js
@@ -4,22 +4,30 @@
 
 (function() {
     ChromeUtils.import("resource://gre/modules/Services.jsm");
     Services.prefs.setBoolPref("javascript.options.showInConsole", true);
     Services.prefs.setBoolPref("browser.dom.window.dump.enabled", true);
     Services.prefs.setBoolPref("calendar.debug.log", true);
     Services.prefs.setBoolPref("calendar.debug.log.verbose", true);
 
-    let bindir = Services.dirsvc.get("CurProcD", Components.interfaces.nsIFile);
-    bindir.append("extensions");
-    bindir.append("{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}");
-    bindir.append("chrome.manifest");
-    dump("Loading" + bindir.path + "\n");
-    Components.manager.autoRegister(bindir);
+    let xpiFile;
+    let env = Cc["@mozilla.org/process/environment;1"].getService(Ci.nsIEnvironment);
+    if (env.exists("MOZ_FETCHES_DIR")) {
+        xpiFile = new FileUtils.File(env.get("MOZ_FETCHES_DIR"));
+        xpiFile.append("gdata-provider.en-US.xpi");
+    } else {
+        xpiFile = Services.dirsvc.get("CurProcD", Components.interfaces.nsIFile);
+        xpiFile.append("extensions");
+        xpiFile.append("{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}");
+    }
+
+    dump("Loading " + xpiFile.path + "\n");
+    let manager = Cc["@mozilla.org/component-manager-extra;1"].getService(Ci.nsIComponentManagerExtra);
+    manager.addLegacyExtensionManifestLocation(xpiFile);
 })();
 
 ChromeUtils.import("resource://testing-common/httpd.js");
 ChromeUtils.import("resource://gre/modules/NetUtil.jsm");
 ChromeUtils.import("resource://gre/modules/Preferences.jsm");
 ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
 
 ChromeUtils.import("resource://gdata-provider/modules/gdataSession.jsm");
@@ -502,48 +510,48 @@ function run_test() {
                     run_next_test();
                     do_test_finished();
                 }
             });
         }
     });
 }
 
-add_task(function* test_migrate_cache() {
+add_task(async function test_migrate_cache() {
     let uriString = "googleapi://xpcshell/?calendar=xpcshell%40example.com";
     let uri = Services.io.newURI(uriString);
     let client = cal.getCalendarManager().createCalendar("gdata", uri);
     let unwrapped = client.wrappedJSObject;
     let migrateStorageCache = unwrapped.migrateStorageCache.bind(unwrapped);
 
     monkeyPatch(unwrapped, "resetSync", (protofunc) => {
         return Promise.resolve();
     });
 
     // No version, should not reset
-    equal(yield migrateStorageCache(), false);
+    equal(await migrateStorageCache(), false);
     equal(client.getProperty("cache.version"), 3);
 
     // Check migrate 1 -> 2
     unwrapped.CACHE_DB_VERSION = 2;
     client.setProperty("cache.version", 1);
-    equal(yield migrateStorageCache(), true);
+    equal(await migrateStorageCache(), true);
     equal(client.getProperty("cache.version"), 2);
 
     // Check migrate 2 -> 3 normal calendar
     unwrapped.CACHE_DB_VERSION = 3;
     client.setProperty("cache.version", 2);
-    equal(yield migrateStorageCache(), false);
+    equal(await migrateStorageCache(), false);
 
     // Check migrate 2 -> 3 birthday calendar
     unwrapped.CACHE_DB_VERSION = 3;
     uri = "googleapi://xpcshell/?calendar=%23contacts%40group.v.calendar.google.com";
     unwrapped.uri = Services.io.newURI(uri);
     client.setProperty("cache.version", 2);
-    equal(yield migrateStorageCache(), true);
+    equal(await migrateStorageCache(), true);
 });
 
 add_test(function test_migrate_uri() {
     function checkMigrate(fromUri, session, calendarId, tasksId) {
         let uri = Services.io.newURI(fromUri);
         let client = cal.getCalendarManager().createCalendar("gdata", uri);
 
         if (session) {
@@ -567,17 +575,17 @@ add_test(function test_migrate_uri() {
                  "example@example.com", "example@example.com", "@default");
 
     checkMigrate("ehmwtf://www.google.com/calendar/feeds/example%40example.com/public/full");
     checkMigrate("googleapi://session/?calendar=calendarId&tasksId=tasksId");
 
     run_next_test();
 });
 
-add_task(function* test_dateToJSON() {
+add_task(async function test_dateToJSON() {
     function _createDateTime(tzid, offset=0) {
         let offsetFrom = offset <= 0 ? "-0" + (offset - 1) : "+0" + (offset - 1) + "00";
         let offsetTo = "+0" + offset + "00";
         let ics = ["BEGIN:VCALENDAR",
             "BEGIN:VTIMEZONE",
             "TZID:ThirdPartyZone",
             "BEGIN:STANDARD",
             "DTSTART:20071104T020000",
@@ -666,17 +674,17 @@ add_task(function* test_dateToJSON() {
     date = _createDateTime("Europe/London");
     deepEqual(dateToJSON(date), { dateTime: "2015-01-30T12:00:00", timeZone: "Europe/London" });
 
     // date only
     date.isDate = true;
     deepEqual(dateToJSON(date), { date: "2015-01-30" });
 });
 
-add_task(function* test_JSONToDate() {
+add_task(async function test_JSONToDate() {
     function convert(aEntry, aTimezone="Europe/Berlin") {
         let tzs = cal.getTimezoneService();
         let calendarTz = tzs.getTimezone(aTimezone);
         let date = JSONToDate(aEntry, calendarTz);
         return date ? date.icalString + " in " + date.timezone.tzid : null;
     }
 
     // A date, using the passed in default timezone
@@ -710,75 +718,75 @@ add_task(function* test_JSONToDate() {
     // An offset matching the passed in calendar timezone. This should NOT be Africa/Algiers
     equal(convert({ dateTime: "2015-01-02T03:04:05+01:00" }), "20150102T030405 in Europe/Berlin");
 
     // An offset that doesn't match the calendar timezone, will use the first timezone in that offset
     info("The following warning is expected: 2015-01-02T03:04:05+04:00 does not match timezone offset for Europe/Berlin");
     equal(convert({ dateTime: "2015-01-02T03:04:05+05:00" }), "20150102T030405 in Antarctica/Mawson");
 });
 
-add_task(function* test_organizerCN() {
+add_task(async function test_organizerCN() {
     gServer.events = [];
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     equal(client.getProperty("organizerCN"), null);
     gServer.resetClient(client);
 
     gServer.events = [{
         kind: "calendar#event",
         etag: "\"2299601498276000\"",
         id: "go6ijb0b46hlpbu4eeu92njevo",
         created: "2006-06-08T21:04:52.000Z",
         updated: "2006-06-08T21:05:49.138Z",
         summary: "New Event",
         creator: gServer.creator,
         organizer: gServer.creator,
         start: { dateTime: "2006-06-10T18:00:00+02:00" },
         end: { dateTime: "2006-06-10T20:00:00+02:00" },
         iCalUID: "go6ijb0b46hlpbu4eeu92njevo@google.com"
     }];
-    client = yield gServer.getClient();
+    client = await gServer.getClient();
     equal(client.getProperty("organizerCN"), gServer.creator.displayName);
     gServer.resetClient(client);
 });
 
-add_task(function* test_always_readOnly() {
+add_task(async function test_always_readOnly() {
     gServer.events = [{
         kind: "calendar#event",
         etag: "\"2299601498276000\"",
         id: "go6ijb0b46hlpbu4eeu92njevo",
         created: "2006-06-08T21:04:52.000Z",
         updated: "2006-06-08T21:05:49.138Z",
         summary: "New Event",
         creator: gServer.creator,
         organizer: gServer.creator,
         start: { dateTime: "2006-06-10T18:00:00+02:00" },
         end: { dateTime: "2006-06-10T20:00:00+02:00" },
         iCalUID: "go6ijb0b46hlpbu4eeu92njevo@google.com"
     }];
     gServer.calendarListData.accessRole = "freeBusyReader";
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client);
     ok(client.readOnly);
     client.readOnly = false;
     ok(client.readOnly);
 
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
     equal(items.length, 1);
     notEqual(items[0].title, "New Event");
     gServer.resetClient(client);
 
     gServer.calendarListData.accessRole = "reader";
-    client = yield gServer.getClient();
+    client = await gServer.getClient();
     ok(client.readOnly);
     client.readOnly = false;
     ok(client.readOnly);
     gServer.resetClient(client);
 });
 
-add_task(function* test_reset_sync() {
+add_task(async function test_reset_sync() {
     gServer.tasks = [{
         kind: "tasks#task",
         id: "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
         etag: "\"Lck7VNWFJuXdzMtOmrYPx0KFV2s/LTIwNjA4MDcyNDM\"",
         title: "New Task",
         updated: "2014-09-08T16:30:27.000Z",
         selfLink: gServer.baseUri + "/tasks/v1/lists/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDow/tasks/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
         position: "00000000000000130998",
@@ -813,37 +821,37 @@ add_task(function* test_reset_sync() {
         updated: "2006-06-08T21:05:49.138Z",
         summary: "New Event 2",
         creator: gServer.creator,
         organizer: gServer.creator,
         start: { dateTime: "2006-06-10T18:00:00+02:00" },
         end: { dateTime: "2006-06-10T20:00:00+02:00" },
         iCalUID: "fepf8uf6n7n04w7feukucs9n8e@google.com"
     }];
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let uncached = client.wrappedJSObject.mUncachedCalendar.wrappedJSObject;
     let pclient = cal.async.promisifyCalendar(client);
 
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
     equal(items.length, 4);
 
     notEqual(client.getProperty("syncToken.events"), "");
     notEqual(client.getProperty("lastUpdated.tasks"), "");
 
-    yield uncached.resetSync();
-    items = yield pclient.getAllItems();
+    await uncached.resetSync();
+    items = await pclient.getAllItems();
     equal(items.length, 0);
 
     equal(client.getProperty("syncToken.events"), "");
     equal(client.getProperty("lastUpdated.tasks"), "");
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_basicItems() {
+add_task(async function test_basicItems() {
     gServer.events = [{
         kind: "calendar#event",
         etag: "\"2299601498276000\"",
         id: "go6ijb0b46hlpbu4eeu92njevo",
         status: "confirmed",
         htmlLink: gServer.baseUri + "/calendar/event?eid=eventhash",
         created: "2006-06-08T21:04:52.000Z",
         updated: "2006-06-08T21:05:49.138Z",
@@ -897,20 +905,20 @@ add_task(function* test_basicItems() {
         parent: "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo4MDIzOTU2NDc",
         links: [{
             link: "mailto:something@example.com",
             description: "link description",
             type: "email"
         }]
     }];
 
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client);
 
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
     equal(items.length, 2);
 
     let event = cal.item.isEvent(items[0]) ? items[0] : items[1];
     equal(event.id, "go6ijb0b46hlpbu4eeu92njevo@google.com");
     equal(event.getProperty("STATUS"), "CONFIRMED");
     equal(event.getProperty("URL"), gServer.baseUri + "/calendar/event?eid=eventhash");
     equal(event.getProperty("CREATED").icalString, "20060608T210452Z");
     equal(event.getProperty("LAST-MODIFIED").icalString, "20060608T210549Z");
@@ -959,18 +967,18 @@ add_task(function* test_basicItems() {
     equal(attachments.length, 1);
     equal(attachments[0].uri.spec, "mailto:something@example.com");
     equal(attachments[0].getParameter("X-GOOGLE-TYPE"), "email");
     equal(attachments[0].getParameter("FILENAME"), "link description");
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_addModifyDeleteItem() {
-    let client = yield gServer.getClient();
+add_task(async function test_addModifyDeleteItem() {
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
     equal(gServer.events.length, 0);
     equal(gServer.tasks.length, 0);
 
     let event = cal.createEvent([
         "BEGIN:VEVENT",
         "CREATED:20060608T210452Z",
         "LAST-MODIFIED:20060608T210549Z",
@@ -1010,118 +1018,118 @@ add_task(function* test_addModifyDeleteI
         "DUE;VALUE=DATE:20140904",
         "COMPLETED:20140901T170000Z",
         "RELATED-TO;RELTYPE=PARENT:MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo4MDIzOTU2NDc",
         "ATTACH;FILENAME=\"link description\";X-GOOGLE-TYPE=email:mailto:something@example.com",
         "END:VTODO"
     ].join("\r\n"));
 
     // Add an event
-    let addedEvent = yield pclient.adoptItem(event);
+    let addedEvent = await pclient.adoptItem(event);
     notEqual(addedEvent.id, null);
     equal(addedEvent.organizer.id, "mailto:xpcshell@example.com");
 
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
     equal(items.length, 1);
     equal(items[0].id, addedEvent.id);
     equal(items[0].organizer.id, "mailto:xpcshell@example.com");
 
     equal(gServer.events.length, 1);
     equal(gServer.tasks.length, 0);
 
     // Add a task
-    let addedTask = yield pclient.adoptItem(task);
+    let addedTask = await pclient.adoptItem(task);
     notEqual(addedTask.id, null);
 
-    items = yield pclient.getAllItems();
+    items = await pclient.getAllItems();
     equal(items.length, 2);
     equal(items[1].id, addedTask.id);
 
     equal(gServer.events.length, 1);
     equal(gServer.tasks.length, 1);
 
     // Modify an event
     let newEvent = items[0].clone();
     newEvent.title = "changed";
 
-    let modifiedEvent = yield pclient.modifyItem(newEvent, items[0]);
+    let modifiedEvent = await pclient.modifyItem(newEvent, items[0]);
     equal(modifiedEvent.title, "changed");
     notEqual(modifiedEvent.getProperty("LAST-MODIFIED"), addedEvent.getProperty("LAST-MODIFIED"));
-    items = yield pclient.getAllItems();
+    items = await pclient.getAllItems();
     equal(items.length, 2);
     equal(items[0].title, "changed");
     equal(items[0].id, addedEvent.id);
     equal(items[0].getProperty("LAST-MODIFIED"), modifiedEvent.getProperty("LAST-MODIFIED"));
     equal(gServer.events.length, 1);
     equal(gServer.tasks.length, 1);
 
     // Modify a task
     let newTask = items[1].clone();
     newTask.title = "changed";
 
-    let modifiedTask = yield pclient.modifyItem(newTask, items[1]);
+    let modifiedTask = await pclient.modifyItem(newTask, items[1]);
     equal(modifiedTask.title, "changed");
     notEqual(modifiedTask.getProperty("LAST-MODIFIED"), addedTask.getProperty("LAST-MODIFIED"));
-    items = yield pclient.getAllItems();
+    items = await pclient.getAllItems();
     equal(items.length, 2);
     equal(items[1].title, "changed");
     equal(items[1].id, addedTask.id);
     equal(items[1].getProperty("LAST-MODIFIED"), modifiedTask.getProperty("LAST-MODIFIED"));
     equal(gServer.events.length, 1);
     equal(gServer.tasks.length, 1);
 
     // Delete an event
-    yield pclient.deleteItem(modifiedEvent);
-    items = yield pclient.getAllItems();
+    await pclient.deleteItem(modifiedEvent);
+    items = await pclient.getAllItems();
     equal(items.length, 1);
     equal(gServer.events.length, 0);
     equal(gServer.tasks.length, 1);
 
     // Delete a task
-    yield pclient.deleteItem(modifiedTask);
-    items = yield pclient.getAllItems();
+    await pclient.deleteItem(modifiedTask);
+    items = await pclient.getAllItems();
     equal(items.length, 0);
     equal(gServer.events.length, 0);
     equal(gServer.tasks.length, 0);
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_recurring_event() {
-    let client = yield gServer.getClient();
+add_task(async function test_recurring_event() {
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
 
     let event = cal.createEvent([
         "BEGIN:VEVENT",
         "SUMMARY:Recurring Event",
         "DTSTART:20060610T180000Z",
         "DTEND:20060610T200000Z",
         "RRULE:FREQ=WEEKLY",
         "END:VEVENT"
     ].join("\r\n"));
 
-    event = yield pclient.addItem(event);
+    event = await pclient.addItem(event);
     equal(gServer.events.length, 1);
     equal(gServer.events[0].recurrence.length, 1);
     equal(gServer.events[0].recurrence[0], "RRULE:FREQ=WEEKLY");
 
     let occ = event.recurrenceInfo.getNextOccurrence(event.startDate);
     let changedOcc = occ.clone();
     changedOcc.title = "changed";
     event.recurrenceInfo.modifyException(occ, true);
 
-    event = yield pclient.modifyItem(changedOcc, occ);
+    event = await pclient.modifyItem(changedOcc, occ);
     occ = event.recurrenceInfo.getNextOccurrence(event.startDate);
     equal(occ.title, "changed");
     equal(gServer.events.length, 2);
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_recurring_exception() {
+add_task(async function test_recurring_exception() {
     gServer.syncs = [{
         token: "1",
         events: [{
             kind: "calendar#event",
             etag: "\"1\"",
             id: "go6ijb0b46hlpbu4eeu92njevo",
             created: "2006-06-08T21:04:52.000Z",
             updated: "2006-06-08T21:05:49.138Z",
@@ -1156,41 +1164,41 @@ add_task(function* test_recurring_except
             start: { dateTime: "2006-06-17T18:00:00+02:00" },
             end: { dateTime: "2006-06-17T20:00:00+02:00" },
             status: "cancelled",
             recurringEventId: "go6ijb0b46hlpbu4eeu92njevo",
             originalStartTime: { dateTime: "2006-06-17T18:00:00+02:00" }
         }]
     }];
 
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
 
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
     equal(items.length, 1);
 
     let exIds = items[0].recurrenceInfo.getExceptionIds({});
     equal(exIds.length, 1);
 
     let ex = items[0].recurrenceInfo.getExceptionFor(exIds[0]);
     equal(ex.title, "New Event changed");
 
     client.refresh();
-    yield gServer.waitForLoad(client);
+    await gServer.waitForLoad(client);
 
-    items = yield pclient.getAllItems();
+    items = await pclient.getAllItems();
     equal(items.length, 1);
 
     exIds = items[0].recurrenceInfo.getExceptionIds({});
     equal(exIds.length, 0);
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_recurring_cancelled_exception() {
+add_task(async function test_recurring_cancelled_exception() {
     gServer.syncs = [{
         token: "1",
         events: [{
             kind: "calendar#event",
             etag: "\"1\"",
             id: "go6ijb0b46hlpbu4eeu92njevo",
             status: "cancelled",
         }, {
@@ -1198,28 +1206,28 @@ add_task(function* test_recurring_cancel
             etag: "\"2\"",
             id: "go6ijb0b46hlpbu4eeu92njevo_20060617T160000Z",
             status: "cancelled",
             recurringEventId: "go6ijb0b46hlpbu4eeu92njevo",
             originalStartTime: { dateTime: "2006-06-17T18:00:00+02:00" }
         }]
     }];
 
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
 
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
     equal(items.length, 0);
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_import_invitation() {
+add_task(async function test_import_invitation() {
     Preferences.set("calendar.google.enableAttendees", true);
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
     let event = cal.createEvent([
         "BEGIN:VEVENT",
         "UID:xpcshell-import",
         "CREATED:20060608T210452Z",
         "LAST-MODIFIED:20060608T210549Z",
         "DTSTAMP:20060608T210549Z",
         "SUMMARY:New Event",
@@ -1230,24 +1238,24 @@ add_task(function* test_import_invitatio
         "ATTENDEE;CN=Eggs P. Seashell;PARTSTAT=TENTATIVE;CUTYPE=INDIVIDUAL;",
         " ROLE=REQ-PARTICIPANT:mailto:xpcshell@example.com",
         "DTSTART:20060610T180000Z",
         "DTEND:20060610T200000Z",
         "SEQUENCE:1",
         "END:VEVENT"
     ].join("\r\n"));
 
-    let addedItem = yield pclient.adoptItem(event);
+    let addedItem = await pclient.adoptItem(event);
     equal(gServer.events.length, 1);
     equal(addedItem.icalString, event.icalString);
     gServer.resetClient(client);
     Preferences.set("calendar.google.enableAttendees", false);
 });
 
-add_task(function* test_modify_invitation() {
+add_task(async function test_modify_invitation() {
     Preferences.set("calendar.google.enableAttendees", true);
     let organizer = {
         displayName: "organizer name",
         email: "organizer@example.com",
         organizer: true,
         responseStatus: "tentative"
     };
     let attendee = Object.assign({}, gServer.creator);
@@ -1272,36 +1280,36 @@ add_task(function* test_modify_invitatio
         transparency: "transparent",
         visibility: "private",
         iCalUID: "go6ijb0b46hlpbu4eeu92njevo@google.com",
         sequence: 1,
         attendees: [organizer, attendee],
     }];
 
     // Case #1: User is attendee
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
 
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
     equal(items.length, 1);
 
     let item = items[0];
     let att = cal.itip.getInvitedAttendee(item);
     let newItem = item.clone();
 
     notEqual(att, null);
     equal(att.id, "mailto:" + attendee.email);
     equal(att.participationStatus, "NEEDS-ACTION");
 
     newItem.removeAttendee(att);
     att = att.clone();
     att.participationStatus = "ACCEPTED";
     newItem.addAttendee(att);
 
-    yield pclient.modifyItem(newItem, items[0]);
+    await pclient.modifyItem(newItem, items[0]);
     equal(gServer.lastMethod, "PATCH");
 
     // Case #2: User is organizer
     let events = gServer.events;
     gServer.resetClient(client);
     gServer.events = events;
 
     organizer = Object.assign({}, gServer.creator);
@@ -1312,42 +1320,42 @@ add_task(function* test_modify_invitatio
         email: "attendee@example.com",
         responseStatus: "tentative"
     };
 
     gServer.events[0].organizer = gServer.creator;
     gServer.events[0].creator = gServer.creator;
     gServer.events[0].attendees = [organizer, attendee];
 
-    client = yield gServer.getClient();
+    client = await gServer.getClient();
     pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
 
-    items = yield pclient.getAllItems();
+    items = await pclient.getAllItems();
     equal(items.length, 1);
 
     item = items[0];
     let org = item.getAttendeeById("mailto:" + organizer.email);
     newItem = item.clone();
 
     notEqual(org, null);
     equal(org.id, "mailto:" + organizer.email);
     equal(org.participationStatus, "ACCEPTED");
 
     newItem.removeAttendee(org);
     org = org.clone();
     org.participationStatus = "TENTATIVE";
     newItem.addAttendee(org);
 
-    modifiedItem = yield pclient.modifyItem(newItem, items[0]);
+    modifiedItem = await pclient.modifyItem(newItem, items[0]);
     equal(gServer.lastMethod, "PUT");
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_metadata() {
+add_task(async function test_metadata() {
     gServer.events = [{
         kind: "calendar#event",
         etag: "\"1\"",
         id: "go6ijb0b46hlpbu4eeu92njevo",
         created: "2006-06-08T21:04:52.000Z",
         updated: "2006-06-08T21:05:49.138Z",
         summary: "New Event",
         creator: gServer.creator,
@@ -1361,91 +1369,91 @@ add_task(function* test_metadata() {
         id: "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
         etag: "\"2\"",
         title: "New Task",
         updated: "2014-09-08T16:30:27.000Z",
         selfLink: gServer.baseUri + "/tasks/v1/lists/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDow/tasks/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
         notes: "description"
     }];
 
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let offline = client.wrappedJSObject.mCachedCalendar;
     let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
 
     // Check initial metadata
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
     let meta = getAllMeta(offline);
     let [event, task] = items;
     ok(cal.item.isEvent(event));
     ok(cal.item.isToDo(task));
     equal(meta.size, 2);
     equal(meta.get(event.hashId), ['"1"', "go6ijb0b46hlpbu4eeu92njevo", false].join("\u001A"));
     equal(meta.get(task.hashId), ['"2"', "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU", false].join("\u001A"));
 
     // Modify an event
     gServer.nextEtag = '"3"';
     let newEvent = event.clone();
     newEvent.title = "changed";
-    yield pclient.modifyItem(newEvent, event);
+    await pclient.modifyItem(newEvent, event);
 
-    items = yield pclient.getAllItems();
+    items = await pclient.getAllItems();
     meta = getAllMeta(offline);
     [event, task] = items;
     ok(cal.item.isEvent(event));
     ok(cal.item.isToDo(task));
     equal(meta.size, 2);
     equal(meta.get(event.hashId), ['"3"', "go6ijb0b46hlpbu4eeu92njevo", false].join("\u001A"));
     equal(meta.get(task.hashId), ['"2"', "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU", false].join("\u001A"));
 
     // Modify a task
     gServer.nextEtag = '"4"';
     let newTask = task.clone();
     newTask.title = "changed";
-    yield pclient.modifyItem(newTask, task);
+    await pclient.modifyItem(newTask, task);
 
-    items = yield pclient.getAllItems();
+    items = await pclient.getAllItems();
     meta = getAllMeta(offline);
     [event, task] = items;
     equal(meta.size, 2);
     equal(meta.get(event.hashId), ['"3"', "go6ijb0b46hlpbu4eeu92njevo", false].join("\u001A"));
     equal(meta.get(task.hashId), ['"4"', "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU", false].join("\u001A"));
 
     // Delete an event
-    yield pclient.deleteItem(event);
+    await pclient.deleteItem(event);
     meta = getAllMeta(offline);
     equal(meta.size, 1);
     equal(meta.get(task.hashId), ['"4"', "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU", false].join("\u001A"));
 
     // Delete a task
-    yield pclient.deleteItem(task);
+    await pclient.deleteItem(task);
     meta = getAllMeta(offline);
     equal(meta.size, 0);
 
     // Add an event
     gServer.nextEtag = '"6"';
-    newEvent = yield pclient.addItem(event);
+    newEvent = await pclient.addItem(event);
     meta = getAllMeta(offline);
     equal(meta.size, 1);
     equal(gServer.events.length, 1);
     equal(meta.get(newEvent.hashId), ['"6"', gServer.events[0].id, false].join("\u001A"));
 
     // Add a task
     gServer.nextEtag = '"7"';
-    newTask = yield pclient.addItem(task);
+    newTask = await pclient.addItem(task);
     meta = getAllMeta(offline);
     equal(meta.size, 2);
     equal(gServer.events.length, 1);
     equal(gServer.tasks.length, 1);
     equal(meta.get(newEvent.hashId), ['"6"', gServer.events[0].id, false].join("\u001A"));
     equal(meta.get(newTask.hashId), ['"7"', gServer.tasks[0].id, false].join("\u001A"));
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_metadata_recurring() {
+add_task(async function test_metadata_recurring() {
     gServer.events = [{
         kind: "calendar#event",
         etag: "\"1\"",
         id: "go6ijb0b46hlpbu4eeu92njevo",
         created: "2006-06-08T21:04:52.000Z",
         updated: "2006-06-08T21:05:49.138Z",
         summary: "New Event",
         creator: gServer.creator,
@@ -1471,145 +1479,145 @@ add_task(function* test_metadata_recurri
         id: "go6ijb0b46hlpbu4eeu92njevo_20060617T160000Z",
         summary: "New Event next week",
         start: { dateTime: "2006-06-17T18:00:00+02:00" },
         end: { dateTime: "2006-06-17T20:00:00+02:00" },
         recurringEventId: "go6ijb0b46hlpbu4eeu92njevo",
         originalStartTime: { dateTime: "2006-06-17T18:00:00+02:00" }
     }];
 
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let offline = client.wrappedJSObject.mCachedCalendar;
     let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
 
     let meta = getAllMeta(offline);
     equal(meta.size, 3);
     equal(meta.get(items[0].hashId), ['"1"', "go6ijb0b46hlpbu4eeu92njevo", false].join("\u001A"));
 
     // The exception metadata should also exist
     let exIds = items[0].recurrenceInfo.getExceptionIds({});
     equal(exIds.length, 2);
     let ex = items[0].recurrenceInfo.getExceptionFor(exIds[0]);
     equal(meta.get(ex.hashId), ['"2"', "go6ijb0b46hlpbu4eeu92njevo_20060610T160000Z", false].join("\u001A"));
 
     // Changing an exception should retain the metadata entries
     let newEx = ex.clone();
     newEx.title = "New Event changed again";
     gServer.nextEtag = '"4"';
-    yield pclient.modifyItem(newEx, ex);
+    await pclient.modifyItem(newEx, ex);
     meta = getAllMeta(offline);
     equal(meta.size, 3);
     equal(meta.get(newEx.hashId), ['"4"', "go6ijb0b46hlpbu4eeu92njevo_20060610T160000Z", false].join("\u001A"));
 
     // Deleting an exception should delete the metadata, as it turns into an EXDATE
     let newItem = items[0].clone();
     newItem.recurrenceInfo.removeOccurrenceAt(exIds[0]);
-    yield pclient.modifyItem(newItem, items[0]);
+    await pclient.modifyItem(newItem, items[0]);
 
     meta = getAllMeta(offline);
     equal(meta.size, 2);
 
     // Deleting the master item should remove all metadata entries
-    yield pclient.deleteItem(items[0]);
+    await pclient.deleteItem(items[0]);
     meta = getAllMeta(offline);
     equal(meta.size, 0);
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_conflict_modify() {
+add_task(async function test_conflict_modify() {
     // TODO task/event conflicts are handled in the same way so I'm going to
     // skip adding tests for tasks here, but it probably wouldn't hurt to
     // create them at some point.
     gServer.events = [{
         kind: "calendar#event",
         etag: "\"1\"",
         id: "go6ijb0b46hlpbu4eeu92njevo",
         created: "2006-06-08T21:04:52.000Z",
         updated: "2006-06-08T21:05:49.138Z",
         summary: "New Event",
         creator: gServer.creator,
         organizer: gServer.creator,
         start: { dateTime: "2006-06-10T18:00:00+02:00" },
         end: { dateTime: "2006-06-10T20:00:00+02:00" },
         iCalUID: "go6ijb0b46hlpbu4eeu92njevo@google.com"
     }];
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
-    let item = (yield pclient.getAllItems())[0];
+    let item = (await pclient.getAllItems())[0];
 
     // Case #1: Modified on server, modify locally, overwrite conflict
     MockConflictPrompt.overwrite = true;
     let newItem = item.clone();
     newItem.title = "local change";
     gServer.events[0].etag = '"2"';
     gServer.events[0].summary = "remote change";
-    let modifiedItem = yield pclient.modifyItem(newItem, item);
-    item = (yield pclient.getAllItems())[0];
+    let modifiedItem = await pclient.modifyItem(newItem, item);
+    item = (await pclient.getAllItems())[0];
     equal(gServer.events[0].summary, "local change");
     notEqual(gServer.events[0].etag, '"2"');
     equal(item.title, "local change");
     equal(modifiedItem.title, "local change");
     equal(gServer.events.length, 1);
 
     // Case #2: Modified on server, modify locally, don't overwrite conflict
     MockConflictPrompt.overwrite = false;
     gServer.events[0].etag = '"3"';
     gServer.events[0].summary = "remote change";
     try {
-        modifiedItem = yield pclient.modifyItem(newItem, item);
+        modifiedItem = await pclient.modifyItem(newItem, item);
         do_throw("Expected modifyItem to be cancelled");
     } catch (e) {
         // Swallow cancelling the request
         if (e != Components.interfaces.calIErrors.OPERATION_CANCELLED) {
             throw e;
         }
     }
 
-    yield gServer.waitForLoad(client);
+    await gServer.waitForLoad(client);
 
-    item = (yield pclient.getAllItems())[0];
+    item = (await pclient.getAllItems())[0];
     equal(gServer.events[0].summary, "remote change");
     equal(gServer.events[0].etag, '"3"');
     equal(item.title, "remote change");
 
     // Case #3: Modified on server, delete locally, don't overwrite conflict
     MockConflictPrompt.overwrite = false;
     gServer.events[0].etag = '"4"';
     gServer.events[0].summary = "remote change";
     try {
-        yield pclient.deleteItem(item);
+        await pclient.deleteItem(item);
         do_throw("Expected deleteItem to be cancelled");
     } catch (e) {
         // Swallow cancelling the request
         if (e != Components.interfaces.calIErrors.OPERATION_CANCELLED) {
             throw e;
         }
     }
 
-    yield gServer.waitForLoad(client);
+    await gServer.waitForLoad(client);
 
-    item = (yield pclient.getAllItems())[0];
+    item = (await pclient.getAllItems())[0];
     equal(gServer.events[0].summary, "remote change");
     equal(gServer.events[0].etag, '"4"');
     equal(item.title, "remote change");
 
     // Case #4: Modified on server, delete locally, overwrite conflict
     MockConflictPrompt.overwrite = true;
     gServer.events[0].etag = '"5"';
     gServer.events[0].summary = "remote change";
-    yield pclient.deleteItem(item);
-    item = (yield pclient.getAllItems())[0];
+    await pclient.deleteItem(item);
+    item = (await pclient.getAllItems())[0];
     equal(gServer.events.length, 0);
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_conflict_delete() {
+add_task(async function test_conflict_delete() {
     // TODO task/event conflicts are handled in the same way so I'm going to
     // skip adding tests for tasks here, but it probably wouldn't hurt to
     // create them at some point.
     let coreEvent = {
         kind: "calendar#event",
         etag: "\"2\"",
         id: "go6ijb0b46hlpbu4eeu92njevo",
         created: "2006-06-08T21:04:52.000Z",
@@ -1619,100 +1627,100 @@ add_task(function* test_conflict_delete(
         organizer: gServer.creator,
         start: { dateTime: "2006-06-10T18:00:00+02:00" },
         end: { dateTime: "2006-06-10T20:00:00+02:00" },
         iCalUID: "go6ijb0b46hlpbu4eeu92njevo@google.com"
     };
 
     // Load intial event to server
     gServer.events = [coreEvent];
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
-    let item = (yield pclient.getAllItems())[0];
+    let item = (await pclient.getAllItems())[0];
 
     // Case #1: Deleted on server, modify locally, overwrite conflict
     MockConflictPrompt.overwrite = true;
     gServer.events = [];
     let newItem = item.clone();
     newItem.title = "local change";
-    let modifiedItem = yield pclient.modifyItem(newItem, item);
-    item = (yield pclient.getAllItems())[0];
+    let modifiedItem = await pclient.modifyItem(newItem, item);
+    item = (await pclient.getAllItems())[0];
     equal(gServer.events[0].summary, "local change");
     notEqual(gServer.events[0].etag, '"2"');
     equal(item.title, "local change");
     equal(modifiedItem.title, "local change");
     equal(gServer.events.length, 1);
 
     // Case #2: Deleted on server, modify locally, don't overwrite conflict
     MockConflictPrompt.overwrite = false;
     gServer.events = [];
     try {
-        modifiedItem = yield pclient.modifyItem(newItem, item);
+        modifiedItem = await pclient.modifyItem(newItem, item);
         do_throw("Expected modifyItem to be cancelled");
     } catch (e) {
         // Swallow cancelling the request
         if (e != Components.interfaces.calIErrors.OPERATION_CANCELLED) {
             throw e;
         }
     }
     // The next synchronize should cause the event to be deleted locally.
     coreEvent.status = "cancelled";
     gServer.events = [coreEvent];
 
-    yield gServer.waitForLoad(client);
+    await gServer.waitForLoad(client);
 
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
     equal(items.length, 0);
     equal(gServer.events.length, 1);
 
     // Put the event back in the calendar for the next run
     delete gServer.events[0].status;
     client.refresh();
-    yield gServer.waitForLoad(client);
-    items = yield pclient.getAllItems();
+    await gServer.waitForLoad(client);
+    items = await pclient.getAllItems();
     equal(items.length, 1);
 
     // Case #3: Deleted on server, delete locally, don't overwrite conflict
     MockConflictPrompt.overwrite = false;
     gServer.events = [];
     try {
-        yield pclient.deleteItem(item);
+        await pclient.deleteItem(item);
         do_throw("Expected deleteItem to be cancelled");
     } catch (e) {
         // Swallow cancelling the request
         if (e != Components.interfaces.calIErrors.OPERATION_CANCELLED) {
             throw e;
         }
     }
     // The next synchronize should cause the event to be deleted locally.
     coreEvent.status = "cancelled";
     gServer.events = [coreEvent];
-    yield gServer.waitForLoad(client);
+    await gServer.waitForLoad(client);
 
-    items = yield pclient.getAllItems();
+    items = await pclient.getAllItems();
     equal(items.length, 0);
 
     // Put the event back in the calendar for the next run
     delete gServer.events[0].status;
     client.refresh();
-    yield gServer.waitForLoad(client);
-    items = yield pclient.getAllItems();
+    await gServer.waitForLoad(client);
+    items = await pclient.getAllItems();
     equal(items.length, 1);
 
     // Case #4: Deleted on server, delete locally, overwrite conflict
     MockConflictPrompt.overwrite = true;
     gServer.events = [];
-    yield pclient.deleteItem(item);
-    items = yield pclient.getAllItems();
+    await pclient.deleteItem(item);
+    items = await pclient.getAllItems();
     equal(items.length, 0);
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_default_alarms() {
+add_task(async function test_default_alarms() {
     let defaultReminders = [
         { method: "popup", minutes: 10 },
         { method: "email", minutes: 20 },
     ];
     gServer.calendarListData.defaultReminders = defaultReminders;
     gServer.eventsData.defaultReminders = defaultReminders;
     gServer.events = [{
         kind: "calendar#event",
@@ -1725,21 +1733,21 @@ add_task(function* test_default_alarms()
         organizer: gServer.creator,
         start: { dateTime: "2006-06-10T18:00:00+02:00" },
         end: { dateTime: "2006-06-10T20:00:00+02:00" },
         iCalUID: "go6ijb0b46hlpbu4eeu92njevo@google.com",
         reminders: { useDefault: true }
     }];
 
     // Case #1: read default alarms from event stream
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
     equal(client.getProperty("settings.defaultReminders"), JSON.stringify(defaultReminders));
 
-    let item = (yield pclient.getAllItems())[0];
+    let item = (await pclient.getAllItems())[0];
     let alarms = item.getAlarms({});
 
     equal(alarms.length, 2);
     ok(alarms.every(x => x.getProperty("X-DEFAULT-ALARM") == "TRUE"));
     equal(alarms[0].action, "DISPLAY");
     equal(alarms[0].offset.icalString, "-PT10M");
     equal(alarms[1].action, "EMAIL");
     equal(alarms[1].offset.icalString, "-PT20M");
@@ -1754,17 +1762,17 @@ add_task(function* test_default_alarms()
         "X-DEFAULT-ALARM:TRUE",
         "ACTION:DISPLAY",
         "TRIGGER;VALUE=DURATION:PT0S",
         "DESCRIPTION:Description",
         "END:VALARM",
         "END:VEVENT"
     ].join("\r\n"));
 
-    yield pclient.addItem(event);
+    await pclient.addItem(event);
     ok(gServer.events[1].reminders.useDefault);
     equal(gServer.events[1].reminders.overrides.length, 0);
 
     // Case #3: Mixed default/non-default alarms. Not sure this will happen
     event = cal.createEvent([
         "BEGIN:VEVENT",
         "SUMMARY:Default Alarms",
         "DTSTART:20060610T180000Z",
@@ -1778,57 +1786,57 @@ add_task(function* test_default_alarms()
         "BEGIN:VALARM",
         "ACTION:DISPLAY",
         "TRIGGER;VALUE=DURATION:-PT5M",
         "DESCRIPTION:Description",
         "END:VALARM",
         "END:VEVENT"
     ].join("\r\n"));
 
-    yield pclient.addItem(event);
+    await pclient.addItem(event);
     ok(gServer.events[2].reminders.useDefault);
     equal(gServer.events[2].reminders.overrides.length, 1);
     equal(gServer.events[2].reminders.overrides[0].minutes, 5);
 
     gServer.resetClient(client);
 
     // Case #4a: Empty default alarms
     gServer.calendarListData.defaultReminders = [];
     gServer.eventsData.defaultReminders = [];
-    client = yield gServer.getClient();
+    client = await gServer.getClient();
     pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
 
     event = cal.createEvent([
         "BEGIN:VEVENT",
         "SUMMARY:Default Alarms Empty",
         "DTSTART:20060610T180000Z",
         "DTEND:20060610T200000Z",
         "X-DEFAULT-ALARM:TRUE",
         "END:VEVENT"
     ].join("\r\n"));
 
-    yield pclient.addItem(event);
+    await pclient.addItem(event);
     ok(gServer.events[0].reminders.useDefault);
     equal(gServer.events[0].reminders.overrides, undefined);
 
     let events = gServer.events;
     gServer.resetClient(client);
 
     // Case #4b: Read an item with empty default alarms
     gServer.events = events;
-    client = yield gServer.getClient();
+    client = await gServer.getClient();
     pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
 
-    item = (yield pclient.getAllItems())[0];
+    item = (await pclient.getAllItems())[0];
     equal(item.getProperty("X-DEFAULT-ALARM"), "TRUE");
 
     gServer.resetClient(client);
 });
 
-add_task(function* test_paginate() {
+add_task(async function test_paginate() {
     gServer.events = [{
         kind: "calendar#event",
         etag: "\"1\"",
         id: "go6ijb0b46hlpbu4eeu92njevo",
         created: "2006-06-08T21:04:52.000Z",
         updated: "2006-06-08T21:05:49.138Z",
         summary: "New Event",
         creator: gServer.creator,
@@ -1867,35 +1875,35 @@ add_task(function* test_paginate() {
         updated: "2014-09-08T16:30:27.000Z",
         selfLink: gServer.baseUri + "/tasks/v1/lists/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDow/tasks/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo5OTU0Mjk2MzQ",
         position: "00000000000000130993",
         status: "needsAction"
     }];
 
     Preferences.set("calendar.google.maxResultsPerRequest", 1);
 
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client);
 
     // Make sure all pages were requested
     equal(gServer.eventsData.nextPageToken, null);
     equal(gServer.tasksData.nextPageToken, null);
 
     // ...and we have all items. Not checking props
     // because the other tests do this sufficiently.
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
     equal(items.length, 4);
 
     equal(client.getProperty("syncToken.events"), "next-sync-token");
 
     Preferences.reset("calendar.google.maxResultsPerRequest");
     gServer.resetClient(client);
 });
 
-add_task(function* test_incremental_reset() {
+add_task(async function test_incremental_reset() {
     gServer.syncs = [{
         token: "1",
         events: [{
             kind: "calendar#event",
             etag: "\"1\"",
             id: "go6ijb0b46hlpbu4eeu92njevo",
             created: "2006-06-08T21:04:52.000Z",
             updated: "2006-06-08T21:05:49.138Z",
@@ -1920,27 +1928,27 @@ add_task(function* test_incremental_rese
             summary: "New Event 2",
             creator: gServer.creator,
             organizer: gServer.creator,
             start: { dateTime: "2006-06-10T18:00:00+02:00" },
             end: { dateTime: "2006-06-10T20:00:00+02:00" },
             iCalUID: "fepf8uf6n7n04w7feukucs9n8e@google.com"
         }]
     }];
-    let client = yield gServer.getClient();
+    let client = await gServer.getClient();
     let pclient = cal.async.promisifyCalendar(client);
 
-    let items = yield pclient.getAllItems();
+    let items = await pclient.getAllItems();
     equal(items.length, 1);
     equal(items[0].title, "New Event");
 
     client.refresh();
-    yield gServer.waitForLoad(client);
+    await gServer.waitForLoad(client);
 
-    items = yield pclient.getAllItems();
+    items = await pclient.getAllItems();
     equal(items.length, 1);
     equal(items[0].title, "New Event 2");
 
     equal(gServer.syncs.length, 0);
     equal(client.getProperty("syncToken.events"), "last");
 
     gServer.resetClient(client);
 });
diff --git a/calendar/test/unit/xpcshell-shared.ini b/calendar/test/unit/xpcshell-shared.ini
--- a/calendar/test/unit/xpcshell-shared.ini
+++ b/calendar/test/unit/xpcshell-shared.ini
@@ -24,18 +24,18 @@
 [test_datetime_before_1970.js]
 [test_datetimeformatter.js]
 [test_deleted_items.js]
 [test_duration.js]
 [test_extract.js]
 [test_email_utils.js]
 [test_freebusy.js]
 [test_freebusy_service.js]
-#[test_gdata_provider.js]
-#requesttimeoutfactor = 2
+[test_gdata_provider.js]
+requesttimeoutfactor = 2
 [test_hashedarray.js]
 [test_ics.js]
 [test_ics_parser.js]
 [test_ics_service.js]
 [test_imip.js]
 [test_items.js]
 [test_ltninvitationutils.js]
 [test_providers.js]
diff --git a/mail/app.mozbuild b/mail/app.mozbuild
--- a/mail/app.mozbuild
+++ b/mail/app.mozbuild
@@ -16,16 +16,17 @@ if CONFIG['MOZ_EXTENSIONS']:
     DIRS += ['/%s/extensions' % CONFIG['mozreltopsrcdir']]
 
 DIRS += ['/%s' % CONFIG['MOZ_BRANDING_DIRECTORY']]
 
 
 if CONFIG['MOZ_CALENDAR']:
     DIRS += [
         '/%s/calendar/lightning' % CONFIG['commreltopsrcdir'],
-        '/%s/calendar/timezones' % CONFIG['commreltopsrcdir']
+        '/%s/calendar/providers/gdata' % CONFIG['commreltopsrcdir'],
+        '/%s/calendar/timezones' % CONFIG['commreltopsrcdir'],
     ]
 
 DIRS += [
     '/%s/chat' % CONFIG['commreltopsrcdir'],
     '/%s/editor/ui' % CONFIG['commreltopsrcdir'],
     '/%s/mail' % CONFIG['commreltopsrcdir'],
 ]
diff --git a/mail/testsuite-targets.mk b/mail/testsuite-targets.mk
--- a/mail/testsuite-targets.mk
+++ b/mail/testsuite-targets.mk
@@ -56,10 +56,11 @@ else
 package-tests: stage-mozmill
 endif
 
 stage-mozmill: make-stage-dir
 	$(MAKE) -C $(commtopobjdir)/mail/test/mozmill stage-package
 
 stage-calendar: make-stage-dir
 	$(MAKE) -C $(commtopobjdir)/calendar/lightning stage-package
+	$(MAKE) -C $(commtopobjdir)/calendar/providers/gdata stage-package
 
 .PHONY: stage-mozmill stage-calendar
diff --git a/taskcluster/ci/test/tests.yml b/taskcluster/ci/test/tests.yml
--- a/taskcluster/ci/test/tests.yml
+++ b/taskcluster/ci/test/tests.yml
@@ -66,16 +66,19 @@ xpcshell:
                     - remove_executables.py
                     - unittests/thunderbird_extra.py
         extra-options:
             - "--xpcshell-suite=xpcshell"
         requires-signed-builds:
             by-test-platform:
                 windows.*: true
                 default: false
+    fetches:
+        build:
+            - gdata-provider.en-US.xpi
 
 mozmill:
     description: "mozmill test run"
     suite: mozmill
     treeherder-symbol: Z(Z)
     run-on-projects: built-projects
     docker-image:
         in-tree: "desktop1604-test"

