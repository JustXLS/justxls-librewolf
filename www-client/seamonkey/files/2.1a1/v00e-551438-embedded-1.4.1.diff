diff -u8p -r -N -x '.mozconfig*' -x configure src-1.9/configure.in src/configure.in
--- src-1.9/configure.in	2010-03-09 15:43:31.000000000 -0600
+++ src/configure.in	2010-03-10 06:36:27.000000000 -0600
@@ -105,17 +105,17 @@ _SUBDIR_HOST_CC="$HOST_CC"
 _SUBDIR_HOST_CFLAGS="$HOST_CFLAGS"
 _SUBDIR_HOST_CXXFLAGS="$HOST_CXXFLAGS"
 _SUBDIR_HOST_LDFLAGS="$HOST_LDFLAGS"
 _SUBDIR_CONFIG_ARGS="$ac_configure_args"
 
 dnl Set the version number of the libs included with mozilla
 dnl ========================================================
 MOZJPEG=62
-MOZPNG=10400
+MOZPNG=10401
 MOZZLIB=0x1230
 NSPR_VERSION=4
 NSS_VERSION=3
 
 dnl Set the minimum version of toolkit libs used by mozilla
 dnl ========================================================
 GLIB_VERSION=1.2.0
 LIBIDL_VERSION=0.6.3
diff -u8p -r -N -x '.mozconfig*' -x configure src-1.9/modules/libpr0n/decoders/png/nsPNGDecoder.cpp src/modules/libpr0n/decoders/png/nsPNGDecoder.cpp
--- src-1.9/modules/libpr0n/decoders/png/nsPNGDecoder.cpp	2010-03-09 15:45:39.000000000 -0600
+++ src/modules/libpr0n/decoders/png/nsPNGDecoder.cpp	2010-03-10 07:31:23.000000000 -0600
@@ -67,21 +67,16 @@ static void PNGAPI row_callback(png_stru
 static void PNGAPI frame_info_callback(png_structp png_ptr,
                                        png_uint_32 frame_num);
 #endif
 static void PNGAPI end_callback(png_structp png_ptr, png_infop info_ptr);
 static void PNGAPI error_callback(png_structp png_ptr,
                                   png_const_charp error_msg);
 static void PNGAPI warning_callback(png_structp png_ptr,
                                     png_const_charp warning_msg);
-#if defined(PNG_USER_MEM_SUPPORTED) && !defined(PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED)
-static png_voidp PNGAPI malloc_callback(png_structp png_ptr,
-                                        png_alloc_size_t size);
-#endif
-
 #ifdef PR_LOGGING
 static PRLogModuleInfo *gPNGLog = PR_NewLogModule("PNGDecoder");
 static PRLogModuleInfo *gPNGDecoderAccountingLog =
                         PR_NewLogModule("PNGDecoderAccounting");
 #endif
 
 /* limit image dimensions (bug #251381) */
 #define MOZ_PNG_MAX_DIMENSION 1000000L
@@ -286,60 +281,40 @@ NS_IMETHODIMP nsPNGDecoder::Init(imgICon
     return NS_OK;
   }
 
   /* For full decodes, do png init stuff */
 
   /* Initialize the container's source image header. */
   /* Always decode to 24 bit pixdepth */
 
-#if defined(PNG_USER_MEM_SUPPORTED) && !defined(PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED)
-  if (gfxPlatform::GetCMSMode() != eCMSMode_Off) {
-    mPNG = png_create_read_struct_2(PNG_LIBPNG_VER_STRING,
-                                    NULL,
-                                    error_callback,
-                                    warning_callback,
-                                    NULL,
-                                    malloc_callback,
-                                    NULL);
-  } else
-#endif
-    mPNG = png_create_read_struct(PNG_LIBPNG_VER_STRING,
-                                  NULL, error_callback,
-                                  warning_callback);
+  mPNG = png_create_read_struct(PNG_LIBPNG_VER_STRING,
+                                NULL, error_callback,
+                                warning_callback);
   if (!mPNG)
     return NS_ERROR_OUT_OF_MEMORY;
 
   mInfo = png_create_info_struct(mPNG);
   if (!mInfo) {
     png_destroy_read_struct(&mPNG, NULL, NULL);
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
 #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
   /* Ignore unused chunks */
   if (gfxPlatform::GetCMSMode() == eCMSMode_Off)
     png_set_keep_unknown_chunks(mPNG, 1, color_chunks, 2);
 
   png_set_keep_unknown_chunks(mPNG, 1, unused_chunks,
-     (int)sizeof(unused_chunks)/5);   
+                              (int)sizeof(unused_chunks)/5);   
 #endif
 
-#ifndef MOZPNGCONF_H
-# if defined(PNG_WRITE_SUPPORTED)
-  if (gfxPlatform::GetCMSMode() != eCMSMode_Off) {
-    /* Increase speed of decompressing large iCCP chunks (default buffer
-       size is 8192) */
-    png_set_compression_buffer_size(mPNG, (png_size_t)32768L);
-  }
-
-#   if defined PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
-       png_set_user_chunk_malloc_max(mPNG, 4000000L);
-#   endif
-# endif
+#ifdef PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
+  if (gfxPlatform::GetCMSMode() != eCMSMode_Off)
+    png_set_chunk_malloc_max(mPNG, 4000000L);
 #endif
 
   /* use this as libpng "progressive pointer" (retrieve in callbacks) */
   png_set_progressive_read_fn(mPNG, static_cast<png_voidp>(this),
                               info_callback, row_callback, end_callback);
 
 
   return NS_OK;
@@ -748,35 +723,16 @@ info_callback(png_structp png_ptr, png_i
     if (height < PR_INT32_MAX / (width * channels))
       decoder->interlacebuf = (PRUint8 *)nsMemory::Alloc(channels *
                                                          width * height);
     if (!decoder->interlacebuf) {
       longjmp(png_jmpbuf(decoder->mPNG), 5); // NS_ERROR_OUT_OF_MEMORY
     }
   }
 
-#if defined PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
-  /* Revert to the default memory limit */
-       png_set_user_chunk_malloc_max(decoder->mPNG, PNG_USER_CHUNK_MALLOC_MAX);
-#endif
-#if defined(PNG_USER_MEM_SUPPORTED) && !defined(PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED)
-  /* Revert to the default memory allocator */
-  if (gfxPlatform::GetCMSMode() != eCMSMode_Off)
-     png_set_mem_fn(decoder->mPNG, NULL, NULL, NULL);
-#endif
-
-#ifndef MOZPNGCONF_H
-/* Revert to the default zlib buffer size */
-# if defined(PNG_WRITE_SUPPORTED)
-  if (gfxPlatform::GetCMSMode() != eCMSMode_Off) {
-    png_set_compression_buffer_size(decoder->mPNG, (png_size_t)8192);
-  }
-# endif
-#endif
-
   /* Reject any ancillary chunk after IDAT with a bad CRC (bug #397593).
    * It would be better to show the default frame (if one has already been
    * successfully decoded) before bailing, but it's simpler to just bail
    * out with an error message.
    */
   png_set_crc_action(png_ptr, NULL, PNG_CRC_ERROR_QUIT);
 
   return;
@@ -983,48 +939,8 @@ error_callback(png_structp png_ptr, png_
 
 
 void
 warning_callback(png_structp png_ptr, png_const_charp warning_msg)
 {
   PR_LOG(gPNGLog, PR_LOG_WARNING, ("libpng warning: %s\n", warning_msg));
 }
 
-#if defined(PNG_USER_MEM_SUPPORTED) && !defined(PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED)
-/* Replacement libpng memory allocator that has a 4MB limit */
-png_voidp malloc_callback(png_structp png_ptr, png_alloc_size_t size) {
-
-  png_voidp ret;
-
-  if (png_ptr == NULL || size == 0)
-    return (png_voidp) (NULL);
-
-#ifdef PNG_MAX_MALLOC_64K
-  if (size > (png_uint_32)65536L) {
-         return NULL;
-  }
-#endif
-  if (size > (png_uint_32)4000000L) {
-         return NULL;
-  }
-#if defined(__TURBOC__) && !defined(__FLAT__)
-   if (size != (unsigned long)size)
-      ret = NULL;
-   else
-      ret = farmalloc(size);
-#else
-#  if defined(_MSC_VER) && defined(MAXSEG_64K)
-   if (size != (unsigned long)size)
-      ret = NULL;
-   else
-      ret = halloc(size, 1);
-#  else
-   if (size != (size_t)size)
-      ret = NULL;
-   else
-      ret = malloc((size_t)size);
-#  endif
-#endif
-
-   return (ret);
-}
-#endif /* PNG_USER_MEM_SUPPORTED */
-
