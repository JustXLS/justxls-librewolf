Index: EmbedEventListener.cpp
===================================================================
RCS file: /cvsroot/mozilla/embedding/browser/gtk/src/EmbedEventListener.cpp,v
retrieving revision 1.14
diff -u -p -r1.14 EmbedEventListener.cpp
--- mozilla/embedding/browser/gtk/src/EmbedEventListener.cpp	1 May 2007 22:24:25 -0000	1.14
+++ mozilla/embedding/browser/gtk/src/EmbedEventListener.cpp	20 Sep 2007 19:00:56 -0000
@@ -55,8 +55,10 @@
 #include "EmbedPrivate.h"
 #include "gtkmozembed_internal.h"
 
-static PRInt32 sLongPressTimer = 0, mLongMPressDelay = 1000;
+#define moz_g_source_remove(x) do { if (g_source_remove(x)) x=0; } while (0)
+
 static PRInt32 sX = 0, sY = 0;
+static PRUint32 sLongPressTimer = 0, mLongMPressDelay = 1;
 static PRBool  sMPressed = PR_FALSE, sIsScrolling = PR_FALSE;
 static char* gFavLocation = NULL;
 
@@ -316,23 +318,27 @@ EmbedEventListener::MouseDown(nsIDOMEven
 
   // Return TRUE from your signal handler to mark the event as consumed.
   sMPressed = PR_TRUE;
-  gint return_val = FALSE;
+  gint handled = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_DOWN],
-                  (void *)mouseEvent, &return_val);
-  if (return_val) {
+                  (void *)mouseEvent, &handled);
+  if (!handled) {
     mClickCount = 2;
     sMPressed = PR_FALSE;
 #if 1
-    if (sLongPressTimer)
-      g_source_remove(sLongPressTimer);
+    if (sLongPressTimer != 0)
+      moz_g_source_remove(sLongPressTimer);
 #else
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
 #endif
   } else {
     mClickCount = 1;
-    sLongPressTimer = g_timeout_add(mLongMPressDelay, sLongMPress, mOwner->mOwningWidget);
+#if (GLIB_CHECK_VERSION(2, 14, 0))
+    sLongPressTimer = g_timeout_add_seconds(mLongMPressDelay, sLongMPress, mOwner->mOwningWidget);
+#else
+    sLongPressTimer = g_timeout_add(mLongMPressDelay * 1000, sLongMPress, mOwner->mOwningWidget);
+#endif
     ((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&sX);
     ((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&sY);
   }
@@ -355,8 +361,8 @@ EmbedEventListener::MouseUp(nsIDOMEvent*
   HandleSelection(mouseEvent);
 
   // Return TRUE from your signal handler to mark the event as consumed.
-  if (sLongPressTimer)
-    g_source_remove(sLongPressTimer);
+  if (sLongPressTimer != 0)
+    moz_g_source_remove(sLongPressTimer);
   sMPressed = PR_FALSE;
   mOwner->mOpenBlock = sIsScrolling;
   sIsScrolling = sMPressed;
@@ -399,8 +405,8 @@ EmbedEventListener::MouseDblClick(nsIDOM
   if (!mouseEvent)
     return NS_OK;
   // Return TRUE from your signal handler to mark the event as consumed.
-  if (sLongPressTimer)
-    g_source_remove(sLongPressTimer);
+  if (sLongPressTimer != 0)
+    moz_g_source_remove(sLongPressTimer);
   sMPressed = PR_FALSE;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
@@ -543,8 +549,8 @@ EmbedEventListener::MouseMove(nsIDOMEven
       }
       if (sIsScrolling)
       {
-        if (sLongPressTimer)
-          g_source_remove(sLongPressTimer);
+        if (sLongPressTimer != 0)
+          moz_g_source_remove(sLongPressTimer);
         if (mCtxInfo->mNSHHTMLElementSc) {
           PRInt32 x, y;
           mCtxInfo->mNSHHTMLElementSc->GetScrollTop(&y);
@@ -621,8 +627,8 @@ EmbedEventListener::Blur(nsIDOMEvent* aE
 #else
     if (targetContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL)) {
 #endif
-      if (sLongPressTimer)
-        g_source_remove(sLongPressTimer);
+      if (sLongPressTimer != 0)
+        moz_g_source_remove(sLongPressTimer);
 
       sMPressed = sIsScrolling ? PR_FALSE : sMPressed;
       sIsScrolling = PR_FALSE;
