work around new features that are not avaliable in system-cairo on linux 
(romaxa's patch with modification for return failure with <gcc-4.5)

diff --git a/gfx/thebes/gfxASurface.cpp b/gfx/thebes/gfxASurface.cpp
--- a/gfx/thebes/gfxASurface.cpp
+++ b/gfx/thebes/gfxASurface.cpp
@@ -216,19 +216,21 @@ gfxASurface::Init(cairo_surface_t* surfa
 
     mSurface = surface;
     mSurfaceValid = PR_TRUE;
 
     if (existingSurface) {
         mFloatingRefs = 0;
     } else {
         mFloatingRefs = 1;
+#ifdef MOZ_TREE_CAIRO
         if (cairo_surface_get_content(surface) != CAIRO_CONTENT_COLOR) {
             cairo_surface_set_subpixel_antialiasing(surface, CAIRO_SUBPIXEL_ANTIALIASING_DISABLED);
         }
+#endif
     }
 }
 
 gfxASurface::gfxSurfaceType
 gfxASurface::GetType() const
 {
     if (!mSurfaceValid)
         return (gfxSurfaceType)-1;
@@ -432,26 +434,32 @@ gfxASurface::FormatFromContent(gfxASurfa
     }
 }
 
 void
 gfxASurface::SetSubpixelAntialiasingEnabled(PRBool aEnabled)
 {
     if (!mSurfaceValid)
         return;
+#ifdef MOZ_TREE_CAIRO
     cairo_surface_set_subpixel_antialiasing(mSurface,
         aEnabled ? CAIRO_SUBPIXEL_ANTIALIASING_ENABLED : CAIRO_SUBPIXEL_ANTIALIASING_DISABLED);
+#endif
 }
 
 PRBool
 gfxASurface::GetSubpixelAntialiasingEnabled()
 {
     if (!mSurfaceValid)
       return PR_FALSE;
+#ifdef MOZ_TREE_CAIRO
     return cairo_surface_get_subpixel_antialiasing(mSurface) == CAIRO_SUBPIXEL_ANTIALIASING_ENABLED;
+#else
+    return PR_FALSE;
+#endif
 }
 
 PRInt32
 gfxASurface::BytePerPixelFromFormat(gfxImageFormat format)
 {
     switch (format) {
         case ImageFormatARGB32:
         case ImageFormatRGB24:
diff --git a/gfx/thebes/gfxTeeSurface.cpp b/gfx/thebes/gfxTeeSurface.cpp
--- a/gfx/thebes/gfxTeeSurface.cpp
+++ b/gfx/thebes/gfxTeeSurface.cpp
@@ -41,37 +41,46 @@
 
 gfxTeeSurface::gfxTeeSurface(cairo_surface_t *csurf)
 {
     Init(csurf, PR_TRUE);
 }
 
 gfxTeeSurface::gfxTeeSurface(gfxASurface **aSurfaces, PRInt32 aSurfaceCount)
 {
+#ifdef MOZ_TREE_CAIRO
     NS_ASSERTION(aSurfaceCount > 0, "Must have a least one surface");
     cairo_surface_t *csurf = cairo_tee_surface_create(aSurfaces[0]->CairoSurface());
     Init(csurf, PR_FALSE);
 
     for (PRInt32 i = 1; i < aSurfaceCount; ++i) {
         cairo_tee_surface_add(csurf, aSurfaces[i]->CairoSurface());
     }
+#endif
 }
 
-const gfxIntSize
-gfxTeeSurface::GetSize() const
-{
-    nsRefPtr<gfxASurface> master = Wrap(cairo_tee_surface_index(mSurface, 0));
-    return master->GetSize();
+const gfxIntSize                                                                
+gfxTeeSurface::GetSize() const                                                  
+{                                                                               
+#ifdef MOZ_TREE_CAIRO                                                           
+    nsRefPtr<gfxASurface> master = Wrap(cairo_tee_surface_index(mSurface, 0));  
+    return master->GetSize();                                                   
+#else                                                                           
+    gfxIntSize a;                                                               
+    return a;                                                                   
+#endif                                                                          
 }
 
 void
 gfxTeeSurface::GetSurfaces(nsTArray<nsRefPtr<gfxASurface> >* aSurfaces)
 {
+#ifdef MOZ_TREE_CAIRO
     for (PRInt32 i = 0; ; ++i) {
         cairo_surface_t *csurf = cairo_tee_surface_index(mSurface, i);
         if (cairo_surface_status(csurf))
             break;
         nsRefPtr<gfxASurface> *elem = aSurfaces->AppendElement();
         if (!elem)
             return;
         *elem = Wrap(csurf);
     }
+#endif
 }
