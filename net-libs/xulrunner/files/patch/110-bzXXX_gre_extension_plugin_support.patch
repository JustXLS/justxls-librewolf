---
 toolkit/mozapps/extensions/src/nsExtensionManager.js.in |   27 ++++++---
 toolkit/xre/nsXREDirProvider.cpp                        |    5 +
 xpcom/io/nsAppDirectoryServiceDefs.h                    |    1 
 xpcom/io/nsAppFileLocationProvider.cpp                  |   47 ++++++++++++++--
 xpcom/io/nsAppFileLocationProvider.h                    |    2 
 5 files changed, 71 insertions(+), 11 deletions(-)

Index: mozilla/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
===================================================================
--- mozilla.orig/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
+++ mozilla/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
@@ -92,16 +92,17 @@
 const UNKNOWN_XPCOM_ABI               = "unknownABI";
 
 const FILE_DEFAULT_THEME_JAR          = "classic.jar";
 const TOOLKIT_ID                      = "toolkit@mozilla.org"
 
 const KEY_PROFILEDIR                  = "ProfD";
 const KEY_PROFILEDS                   = "ProfDS";
 const KEY_APPDIR                      = "XCurProcD";
+const KEY_GREDIR                      = "GreD";
 const KEY_TEMPDIR                     = "TmpD";
 
 const EM_ACTION_REQUESTED_TOPIC       = "em-action-requested";
 const EM_ITEM_INSTALLED               = "item-installed";
 const EM_ITEM_UPGRADED                = "item-upgraded";
 const EM_ITEM_UNINSTALLED             = "item-uninstalled";
 const EM_ITEM_ENABLED                 = "item-enabled";
 const EM_ITEM_DISABLED                = "item-disabled";
@@ -111,16 +112,17 @@
 const OP_NEEDS_INSTALL                = "needs-install";
 const OP_NEEDS_UPGRADE                = "needs-upgrade";
 const OP_NEEDS_UNINSTALL              = "needs-uninstall";
 const OP_NEEDS_ENABLE                 = "needs-enable";
 const OP_NEEDS_DISABLE                = "needs-disable";
 
 const KEY_APP_PROFILE                 = "app-profile";
 const KEY_APP_GLOBAL                  = "app-global";
+const KEY_GRE_GLOBAL                  = "gre-global";
 const KEY_APP_SYSTEM_LOCAL            = "app-system-local";
 const KEY_APP_SYSTEM_SHARE            = "app-system-share";
 const KEY_APP_SYSTEM_USER             = "app-system-user";
 
 const CATEGORY_INSTALL_LOCATIONS      = "extension-install-locations";
 const CATEGORY_UPDATE_PARAMS          = "extension-update-params";
 
 const PREFIX_NS_EM                    = "http://www.mozilla.org/2004/em-rdf#";
@@ -2015,16 +2017,17 @@
               " ... rolling back file moves and aborting installation.");
         rollbackMove();
         cleanUpTrash(itemLocationTrash);
         throw e;
       }
     }
   }
   else if (installLocation.name == KEY_APP_PROFILE ||
+           installLocation.name == KEY_GRE_GLOBAL ||
            installLocation.name == KEY_APP_GLOBAL ||
            installLocation.name == KEY_APP_SYSTEM_USER) {
     // Check for a pointer file and move it aside if it exists
     var pointerFile = installLocation.location.clone();
     pointerFile.append(itemID);
     if (pointerFile.exists() && !pointerFile.isDirectory()) {
       var trashFileName = itemID + "-trash";
       var itemLocationTrash = installLocation.location.clone();
@@ -2421,17 +2424,25 @@
 
   gConsole = Cc["@mozilla.org/consoleservice;1"].
              getService(Ci.nsIConsoleService);
 
   gRDF = Cc["@mozilla.org/rdf/rdf-service;1"].
          getService(Ci.nsIRDFService);
   gInstallManifestRoot = gRDF.GetResource(RDFURI_INSTALL_MANIFEST_ROOT);
 
-  // Register Global Install Location
+  // Register Global GRE Install Location
+  var greGlobalExtensions = getDirNoCreate(KEY_GREDIR, [DIR_EXTENSIONS]);
+  var priority = Ci.nsIInstallLocation.PRIORITY_APP_SYSTEM_GLOBAL;
+  var greGlobalLocation = new DirectoryInstallLocation(KEY_GRE_GLOBAL,
+                                                       greGlobalExtensions, true,
+                                                       priority);
+  InstallLocations.put(greGlobalLocation);
+
+  // Register Global Application Install Location
   var appGlobalExtensions = getDirNoCreate(KEY_APPDIR, [DIR_EXTENSIONS]);
   var priority = Ci.nsIInstallLocation.PRIORITY_APP_SYSTEM_GLOBAL;
   var globalLocation = new DirectoryInstallLocation(KEY_APP_GLOBAL,
                                                     appGlobalExtensions, true,
                                                     priority, false);
   InstallLocations.put(globalLocation);
 
   // Register App-Profile Install Location
@@ -3659,17 +3670,17 @@
         badItems.push(id);
         continue;
       }
 
       if (ds.getItemProperty(id, "appManaged") == "true") {
         // Force an update of the metadata for appManaged extensions since the
         // last modified time is not updated for directories on FAT / FAT32
         // filesystems when software update applies a new version of the app.
-        if (location.name == KEY_APP_GLOBAL) {
+        if (location.name == KEY_APP_GLOBAL || location.name == KEY_GRE_GLOBAL) {
           var installRDF = location.getItemFile(id, FILE_INSTALL_MANIFEST);
           if (installRDF.exists()) {
             var metadataDS = getInstallManifest(installRDF);
             ds.addItemMetadata(id, metadataDS, location);
             ds.updateProperty(id, "compatible");
           }
         }
       }
@@ -3839,17 +3850,17 @@
 
     // return early to avoid migrating data twice if we already have a
     // toolkit 1.8 extension datasource.
     if (dsExists)
       return;
 
     // Prepare themes for installation
     // Only enumerate directories in the app-profile and app-global locations.
-    var locations = [KEY_APP_PROFILE, KEY_APP_GLOBAL];
+    var locations = [KEY_APP_PROFILE, KEY_APP_GLOBAL, KEY_GRE_GLOBAL];
     for (var i = 0; i < locations.length; ++i) {
       var location = InstallLocations.get(locations[i]);
       if (!location.canAccess)
         continue;
 
       var entries = location.itemLocations;
       var entry;
       while ((entry = entries.nextFile)) {
@@ -3905,17 +3916,18 @@
     // items since the datasource hasn't been created yet.
     var itemsToCheck = [];
     if (this._checkForFileChanges()) {
       // Create a list of all items that are to be installed so we can migrate
       // these items's settings to the new datasource.
       var items = PendingOperations.getOperations(OP_NEEDS_INSTALL);
       for (i = items.length - 1; i >= 0; --i) {
         if (items[i].locationKey == KEY_APP_PROFILE ||
-            items[i].locationKey == KEY_APP_GLOBAL)
+            items[i].locationKey == KEY_APP_GLOBAL ||
+            items[i].locationKey == KEY_GRE_GLOBAL)
           itemsToCheck.push(items[i].id);
       }
       this._finishOperations();
     }
 
     // If there are no items to migrate settings for return early.
     if (itemsToCheck.length == 0)
       return;
@@ -5012,16 +5024,17 @@
           StartupCache.put(installLocation, id, OP_NONE, true);
           var restartRequired = this.installRequiresRestart(id, ds.getItemProperty(id, "type"))
           this._updateManifests(restartRequired);
           return;
         }
       }
     }
     else if (installLocation.name == KEY_APP_PROFILE ||
+             installLocation.name == KEY_GRE_GLOBAL ||
              installLocation.name == KEY_APP_GLOBAL ||
              installLocation.name == KEY_APP_SYSTEM_USER) {
       // Check for a pointer file and remove it if it exists
       var pointerFile = installLocation.location.clone();
       pointerFile.append(id);
       if (pointerFile.exists() && !pointerFile.isDirectory())
         pointerFile.remove(false);
     }
@@ -7206,17 +7219,17 @@
       // with and maintained by this application AND it is installed in the
       // global install location (i.e. the place installed by the app installer)
       // it is and can be managed by the update file - it's not an item that has
       // been manually installed by the user into their profile dir, and as such
       // it is always compatible with the next release of the application since
       // we will continue to support it.
       var locationKey = this.getItemProperty(id, "installLocation");
       var appManaged = this.getItemProperty(id, "appManaged") == "true";
-      if (appManaged && locationKey == KEY_APP_GLOBAL)
+      if (appManaged && (locationKey == KEY_APP_GLOBAL || locationKey == KEY_GRE_GLOBAL))
         continue;
 
       if (type != -1 && (type & desiredType) &&
           !this.isCompatible(this, item, appVersion, platformVersion))
         items.push(this.getItemForID(id));
     }
     return items;
   },
@@ -7796,17 +7809,17 @@
     // Assert properties with single values
     var singleProps = ["version", "updateURL", "updateService", "optionsURL",
                        "aboutURL", "iconURL", "internalName", "updateKey"];
 
     // Items installed into restricted Install Locations can also be locked
     // (can't be removed or disabled), and hidden (not shown in the UI)
     if (installLocation.restricted)
       singleProps = singleProps.concat(["locked", "hidden"]);
-    if (installLocation.name == KEY_APP_GLOBAL)
+    if (installLocation.name == KEY_APP_GLOBAL || installLocation.name == KEY_GRE_GLOBAL)
       singleProps = singleProps.concat(["appManaged"]);
     for (var i = 0; i < singleProps.length; ++i) {
       var property = EM_R(singleProps[i]);
       var literal = installManifest.GetTarget(gInstallManifestRoot, property, true);
       // If literal is null, _setProperty will remove any existing.
       this._setProperty(this._inner, targetRes, property, literal);
     }
 
@@ -8466,17 +8479,17 @@
 
   /**
    * Get the em:appManaged property. This prevents extensions from hiding
    * extensions installed into locations other than the app-global location.
    */
   _rdfGet_appManaged: function EMDS__rdfGet_appManaged(item, property) {
     var id = stripPrefix(item.Value, PREFIX_ITEM_URI);
     var locationKey = this.getItemProperty(id, "installLocation");
-    if (locationKey != KEY_APP_GLOBAL)
+    if (locationKey != KEY_APP_GLOBAL && locationKey != KEY_GRE_GLOBAL)
       return EM_L("false");
     return null;
   },
 
   /**
    * Get the em:hidden property. This prevents extensions from hiding
    * extensions installed into locations other than restricted locations.
    */
Index: mozilla/xpcom/io/nsAppDirectoryServiceDefs.h
===================================================================
--- mozilla.orig/xpcom/io/nsAppDirectoryServiceDefs.h
+++ mozilla/xpcom/io/nsAppDirectoryServiceDefs.h
@@ -71,16 +71,17 @@
                                                                                                                        
 #define NS_APP_USER_PROFILES_ROOT_DIR           "DefProfRt"     // The dir where user profile dirs live.
 #define NS_APP_USER_PROFILES_LOCAL_ROOT_DIR     "DefProfLRt"  // The dir where user profile temp dirs live.
 
 #define NS_APP_RES_DIR                          "ARes"
 #define NS_APP_CHROME_DIR                       "AChrom"
 #define NS_APP_PLUGINS_DIR                      "APlugns"       // Deprecated - use NS_APP_PLUGINS_DIR_LIST
 #define NS_APP_SEARCH_DIR                       "SrchPlugns"
+#define NS_GRE_PLUGINS_DIR                      "GrePlugns"     // Usually you want NS_APP_PLUGINS_DIR_LIST
 
 #define NS_APP_CHROME_DIR_LIST                  "AChromDL"
 #define NS_APP_PLUGINS_DIR_LIST                 "APluginsDL"
 #define NS_APP_SEARCH_DIR_LIST                  "SrchPluginsDL"
 
 // --------------------------------------------------------------------------------------
 // Files and directories which exist on a per-profile basis
 // These locations are typically provided by the profile mgr
Index: mozilla/xpcom/io/nsAppFileLocationProvider.cpp
===================================================================
--- mozilla.orig/xpcom/io/nsAppFileLocationProvider.cpp
+++ mozilla/xpcom/io/nsAppFileLocationProvider.cpp
@@ -194,16 +194,22 @@
             rv = localFile->AppendRelativeNativePath(RES_DIR_NAME);
     }
     else if (nsCRT::strcmp(prop, NS_APP_CHROME_DIR) == 0)
     {
         rv = CloneMozBinDirectory(getter_AddRefs(localFile));
         if (NS_SUCCEEDED(rv))
             rv = localFile->AppendRelativeNativePath(CHROME_DIR_NAME);
     }
+    else if (nsCRT::strcmp(prop, NS_GRE_PLUGINS_DIR) == 0)
+    {
+        rv = CloneMozGreDirectory(getter_AddRefs(localFile));
+        if (NS_SUCCEEDED(rv))
+            rv = localFile->AppendRelativeNativePath(PLUGINS_DIR_NAME);
+    }
     else if (nsCRT::strcmp(prop, NS_APP_PLUGINS_DIR) == 0)
     {
         rv = CloneMozBinDirectory(getter_AddRefs(localFile));
         if (NS_SUCCEEDED(rv))
             rv = localFile->AppendRelativeNativePath(PLUGINS_DIR_NAME);
     }
 #ifdef XP_MACOSX
     else if (nsCRT::strcmp(prop, NS_MACOSX_USER_PLUGIN_DIR) == 0)
@@ -276,16 +282,51 @@
 
     if (localFile && NS_SUCCEEDED(rv))
         return localFile->QueryInterface(NS_GET_IID(nsIFile), (void**)_retval);
         
     return rv;
 }
 
 
+NS_METHOD nsAppFileLocationProvider::CloneMozGreDirectory(nsILocalFile **aLocalFile)
+{
+    NS_ENSURE_ARG_POINTER(aLocalFile);
+    nsresult rv;
+
+    if (!mMozGreDirectory)
+    {
+        // Get the mozilla bin directory
+        // 1. Check the directory service first for NS_XPCOM_CURRENT_PROCESS_DIR
+        //    This will be set if a directory was passed to NS_InitXPCOM
+        // 2. If that doesn't work, set it to be the current process directory
+        nsCOMPtr<nsIProperties>
+          directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID, &rv));
+        if (NS_FAILED(rv))
+            return rv;
+
+        rv = directoryService->Get(NS_GRE_DIR, NS_GET_IID(nsIFile), getter_AddRefs(mMozGreDirectory));
+        if (NS_FAILED(rv))
+            return rv;
+    }
+
+    nsCOMPtr<nsIFile> aFile;
+    rv = mMozGreDirectory->Clone(getter_AddRefs(aFile));
+    if (NS_FAILED(rv))
+        return rv;
+
+    nsCOMPtr<nsILocalFile> lfile = do_QueryInterface (aFile);
+    if (!lfile)
+        return NS_ERROR_FAILURE;
+
+    NS_IF_ADDREF(*aLocalFile = lfile);
+    return NS_OK;
+}
+
+
 NS_METHOD nsAppFileLocationProvider::CloneMozBinDirectory(nsILocalFile **aLocalFile)
 {
     NS_ENSURE_ARG_POINTER(aLocalFile);
     nsresult rv;
 
     if (!mMozBinDirectory)
     {
         // Get the mozilla bin directory
@@ -578,30 +619,30 @@
 {
     NS_ENSURE_ARG_POINTER(_retval);
     *_retval = nsnull;
     nsresult rv = NS_ERROR_FAILURE;
     
     if (!nsCRT::strcmp(prop, NS_APP_PLUGINS_DIR_LIST))
     {
 #ifdef XP_MACOSX
-        static const char* osXKeys[] = { NS_APP_PLUGINS_DIR, NS_MACOSX_USER_PLUGIN_DIR, NS_MACOSX_LOCAL_PLUGIN_DIR, nsnull };
-        static const char* os9Keys[] = { NS_APP_PLUGINS_DIR, NS_MAC_CLASSIC_PLUGIN_DIR, nsnull };
+        static const char* osXKeys[] = { NS_APP_PLUGINS_DIR, NS_GRE_PLUGINS_DIR, NS_MACOSX_USER_PLUGIN_DIR, NS_MACOSX_LOCAL_PLUGIN_DIR, nsnull };
+        static const char* os9Keys[] = { NS_APP_PLUGINS_DIR, NS_GRE_PLUGINS_DIR, NS_MAC_CLASSIC_PLUGIN_DIR, nsnull };
         static const char** keys;
         
         if (!keys) {
             OSErr err;
             long response;
             err = ::Gestalt(gestaltSystemVersion, &response); 
             keys = (!err && response >= 0x00001000) ? osXKeys : os9Keys;
         }
 
         *_retval = new nsAppDirectoryEnumerator(this, keys);
 #else
-        static const char* keys[] = { nsnull, NS_USER_PLUGINS_DIR, NS_APP_PLUGINS_DIR, nsnull };
+        static const char* keys[] = { nsnull, NS_USER_PLUGINS_DIR, NS_APP_PLUGINS_DIR, NS_GRE_PLUGINS_DIR, nsnull };
         if (!keys[0] && !(keys[0] = PR_GetEnv("MOZ_PLUGIN_PATH"))) {
             static const char nullstr = 0;
             keys[0] = &nullstr;
         }
         *_retval = new nsPathsDirectoryEnumerator(this, keys);
 #endif
         NS_IF_ADDREF(*_retval);
         rv = *_retval ? NS_OK : NS_ERROR_OUT_OF_MEMORY;        
Index: mozilla/xpcom/io/nsAppFileLocationProvider.h
===================================================================
--- mozilla.orig/xpcom/io/nsAppFileLocationProvider.h
+++ mozilla/xpcom/io/nsAppFileLocationProvider.h
@@ -55,22 +55,24 @@
    NS_DECL_NSIDIRECTORYSERVICEPROVIDER
    NS_DECL_NSIDIRECTORYSERVICEPROVIDER2
 
 private:
                         ~nsAppFileLocationProvider() {}
 
 protected:
    NS_METHOD            CloneMozBinDirectory(nsILocalFile **aLocalFile);
+   NS_METHOD            CloneMozGreDirectory(nsILocalFile **aLocalFile);
    /**
     * Get the product directory. This is a user-specific directory for storing
     * application settings (e.g. the Application Data directory on windows
     * systems).
     * @param aLocal If true, should try to get a directory that is only stored
     *               locally (ie not transferred with roaming profiles)
     */
    NS_METHOD            GetProductDirectory(nsILocalFile **aLocalFile,
                                             PRBool aLocal = PR_FALSE);
    NS_METHOD            GetDefaultUserProfileRoot(nsILocalFile **aLocalFile,
                                                   PRBool aLocal = PR_FALSE);
 
    nsCOMPtr<nsILocalFile> mMozBinDirectory;
+   nsCOMPtr<nsILocalFile> mMozGreDirectory;
 };
Index: mozilla/toolkit/xre/nsXREDirProvider.cpp
===================================================================
--- mozilla.orig/toolkit/xre/nsXREDirProvider.cpp
+++ mozilla/toolkit/xre/nsXREDirProvider.cpp
@@ -747,18 +747,21 @@
 
     rv = NS_NewArrayEnumerator(aResult, directories);
   }
   else if (!strcmp(aProperty, NS_APP_PLUGINS_DIR_LIST)) {
     static const char *const kAppendPlugins[] = { "plugins", nsnull };
     nsCOMArray<nsIFile> directories;
 
     // The root dirserviceprovider does quite a bit for us: we're mainly
-    // interested in xulapp and extension-provided plugins.
+    // interested in gre, xulapp, and extension-provided plugins.
     LoadBundleDirectories();
+    LoadAppDirIntoArray(mGREDir,
+                        kAppendPlugins,
+                        directories);
     LoadDirsIntoArray(mAppBundleDirectories,
                       kAppendPlugins,
                       directories);
     LoadDirsIntoArray(mExtensionDirectories,
                       kAppendPlugins,
                       directories);
 
     rv = NS_NewArrayEnumerator(aResult, directories);
